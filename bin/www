#!/usr/bin/env node

/**
 * Module dependencies.
 */
var express = require('express');
var app = express();
var http = require('http');
/**
 * Create HTTP server.
 */
var server = http.createServer(app);

// added for real time chat
var io = require('socket.io').listen(server);





/*****************
 * REAL TIME CHAT
 * ****************/

var gravatar = require("gravatar");

// Initialize a new socket.io application, named 'chat'
var chat = io.on('connection', function (socket) {

  // When the client emits the 'load' event, reply with the 
  // number of people in this chat room

  socket.on('load',function(data){

    var room = findClientsSocket(io,data);
    if(room.length === 0 ) {

      socket.emit('peopleinchat', {number: 0});
    }
    else if(room.length === 1) {

      socket.emit('peopleinchat', {
        number: 1,
        user: room[0].username,
        avatar: room[0].avatar,
        id: data
      });
    }
    else if(room.length >= 2) {

      chat.emit('tooMany', {boolean: true});
    }
  });

  // When the client emits 'login', save his name and avatar,
  // and add them to the room
  socket.on('login', function(data) {

    var room = findClientsSocket(io, data.id);
    // Only two people per room are allowed
    if (room.length < 2) {

      // Use the socket object to store data. Each client gets
      // their own unique socket object

      socket.username = data.user;
      socket.room = data.id;
      socket.avatar = gravatar.url(data.avatar, {s: '140', r: 'x', d: 'mm'});

      // Tell the person what he should use for an avatar
      socket.emit('img', socket.avatar);


      // Add the client to the room
      socket.join(data.id);

      if (room.length == 1) {

        var usernames = [],
          avatars = [];

        usernames.push(room[0].username);
        usernames.push(socket.username);

        avatars.push(room[0].avatar);
        avatars.push(socket.avatar);

        // Send the startChat event to all the people in the
        // room, along with a list of people that are in it.

        chat.in(data.id).emit('startChat', {
          boolean: true,
          id: data.id,
          users: usernames,
          avatars: avatars
        });
      }
    }
    else {
      socket.emit('tooMany', {boolean: true});
    }
  });

  // Somebody left the chat
  socket.on('disconnect', function() {

    // Notify the other person in the chat room
    // that his partner has left

    socket.broadcast.to(this.room).emit('leave', {
      boolean: true,
      room: this.room,
      user: this.username,
      avatar: this.avatar
    });

    // leave the room
    socket.leave(socket.room);
  });


  // Handle the sending of messages
  socket.on('msg', function(data){

    // When the server receives a message, it sends it to the other person in the room.
    socket.broadcast.to(socket.room).emit('receive', {msg: data.msg, user: data.user, img: data.img});
  });
});

function findClientsSocket(io,roomId, namespace) {
	var res = [],
    ns = io.of("/chat/");    // the default namespace is "/"

  
	if (ns) {
    console.log('emrys:ns', ns.connected);
		for (var id in ns.connected) {
			if(roomId) {

        console.log('emrys:ns.connected[id].rooms: ', ns.connected[id].rooms);
        var index = ns.connected[id].rooms.indexOf(roomId) ;
        if(index !== -1) {
          res.push(ns.connected[id]);
        }
      }
			else {
				res.push(ns.connected[id]);
			}
	  }
	return res;
  }
}




var app = require('../app')(app, io);
var debug = require('debug')('myapp:server');


// initializing sequelize
let models = require('../models');





/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || 3000);
app.set('port', port);


/**
 * Listen on provided port, on all network interfaces.
 */

return models.sequelize.sync().then(result => {
  server.listen(port);
  server.on('error', onError);
  server.on('listening', onListening);
})


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
